<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Thu H·ªìi T√†i S·∫£n">
    <title>Thu H·ªìi T√†i S·∫£n - n8n App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #scanner-wrapper {
            position: relative;
            width: 100%;
            height: 50vh;
            min-height: 300px;
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #scanner video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* Remove filters for clearer image */
        }
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        .scan-area {
            width: 85%;
            max-width: 340px;
            height: 180px;
            border: 3px solid #00ffcc;
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.5);
            border-radius: 16px;
            position: relative;
        }
        .scan-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ff0050, transparent);
            animation: scan 2.5s ease-in-out infinite;
            box-shadow: 0 0 8px #ff0050;
        }
        @keyframes scan {
            0%, 100% { top: 0; opacity: 0; }
            50% { top: calc(100% - 3px); opacity: 1; }
        }
        .corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #00ffcc;
        }
        .corner-tl { top: -3px; left: -3px; border-right: none; border-bottom: none; }
        .corner-tr { top: -3px; right: -3px; border-left: none; border-bottom: none; }
        .corner-bl { bottom: -3px; left: -3px; border-right: none; border-top: none; }
        .corner-br { bottom: -3px; right: -3px; border-left: none; border-top: none; }
        
        .beep-success {
            animation: flash-green 0.3s ease-out;
        }
        @keyframes flash-green {
            0%, 100% { background: transparent; }
            50% { background: rgba(34, 197, 94, 0.3); }
        }
    </style>
</head>

<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/quagga@0.12.1/dist/quagga.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function App() {
            const [barcode, setBarcode] = useState("");
            const [scannedList, setScannedList] = useState([]);
            const [cameraOn, setCameraOn] = useState(false);
            const [photo, setPhoto] = useState(null);
            const [photoPreview, setPhotoPreview] = useState(null);
            const [status, setStatus] = useState("");
            const [loading, setLoading] = useState(false);
            const [webhookUrl, setWebhookUrl] = useState(
                localStorage.getItem("webhookUrl") || "https://your-n8n-instance.com/webhook/thu-hoi-tai-san"
            );
            const [flashEffect, setFlashEffect] = useState(false);
            const [torch, setTorch] = useState(false);

            const fileInputRef = useRef(null);
            const lastScanRef = useRef({ value: null, time: 0 });
            const audioContextRef = useRef(null);
            const videoTrackRef = useRef(null);

            // Check if browser supports native BarcodeDetector
            const supportsBarcodeDetector = "BarcodeDetector" in window;

            // Beep sound on successful scan
            const playBeep = () => {
                try {
                    if (!audioContextRef.current) {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const ctx = audioContextRef.current;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    osc.frequency.value = 800;
                    gain.gain.value = 0.3;
                    
                    osc.start(ctx.currentTime);
                    osc.stop(ctx.currentTime + 0.1);
                } catch (e) {
                    console.log("Beep not supported");
                }
            };

            // Prevent duplicate scans within 2 seconds
            const canAcceptCode = (value) => {
                const now = Date.now();
                if (lastScanRef.current.value === value && now - lastScanRef.current.time < 2000) {
                    return false;
                }
                lastScanRef.current = { value, time: now };
                return true;
            };

            // Camera scanning logic
            useEffect(() => {
                if (!cameraOn) {
                    // Clear scanner when camera is off
                    const scannerEl = document.getElementById("scanner");
                    if (scannerEl) {
                        scannerEl.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #9ca3af; text-align: center; padding: 1rem;">
                                <div>
                                    <span style="font-size: 3rem; display: block; margin-bottom: 0.5rem;">üì∑</span>
                                    <p>Nh·∫•n "B·∫≠t Camera" ƒë·ªÉ qu√©t m√£ v·∫°ch</p>
                                </div>
                            </div>
                        `;
                    }
                    return;
                }

                let stream, detector, rafId, quaggaStarted = false;
                const scannerEl = document.getElementById("scanner");

                const stopAll = () => {
                    console.log("Stopping camera...");
                    
                    // Clear animation frame
                    if (rafId) {
                        clearTimeout(rafId);
                        rafId = null;
                    }
                    
                    // Stop video stream
                    if (stream) {
                        stream.getTracks().forEach(track => {
                            track.stop();
                            console.log("Track stopped:", track.label);
                        });
                        stream = null;
                    }
                    
                    // Stop Quagga
                    if (quaggaStarted) {
                        try {
                            Quagga.stop();
                            quaggaStarted = false;
                            console.log("Quagga stopped");
                        } catch (e) {
                            console.log("Quagga stop error:", e);
                        }
                    }
                    
                    // Clear scanner element completely
                    if (scannerEl) {
                        scannerEl.innerHTML = "";
                        console.log("Scanner cleared");
                    }
                };

                // Native BarcodeDetector API (Chrome/Edge)
                const startNative = async () => {
                    try {
                        // Clear scanner first
                        scannerEl.innerHTML = "";
                        
                        detector = new BarcodeDetector({
                            formats: ["qr_code", "code_128", "code_39", "ean_13", "ean_8", "upc_a", "upc_e"]
                        });

                        // Request high quality camera with optimal settings
                        stream = await navigator.mediaDevices.getUserMedia({
                            video: {
                                facingMode: "environment",
                                width: { min: 640, ideal: 1920, max: 4096 },
                                height: { min: 480, ideal: 1080, max: 2160 },
                                aspectRatio: { ideal: 16/9 },
                                frameRate: { min: 15, ideal: 30, max: 60 },
                                focusMode: "continuous",
                                exposureMode: "continuous",
                                whiteBalanceMode: "continuous"
                            }
                        });

                        const video = document.createElement("video");
                        video.setAttribute("playsinline", "");
                        video.setAttribute("autoplay", "");
                        video.setAttribute("muted", "");
                        video.style.width = "100%";
                        video.style.height = "100%";
                        video.style.objectFit = "cover";
                        video.srcObject = stream;
                        
                        scannerEl.appendChild(video);
                        
                        await video.play();
                        console.log("Native camera started");

                        // Save track reference for controls
                        const track = stream.getVideoTracks()[0];
                        videoTrackRef.current = track;
                        const capabilities = track.getCapabilities?.();
                        const settings = track.getSettings();
                        
                        console.log("Camera capabilities:", capabilities);
                        console.log("Current settings:", settings);
                        
                        if (capabilities) {
                            try {
                                const advancedConstraints = {
                                    advanced: []
                                };
                                
                                // Focus optimization
                                if (capabilities.focusMode) {
                                    if (capabilities.focusMode.includes("continuous")) {
                                        advancedConstraints.advanced.push({ focusMode: "continuous" });
                                    } else if (capabilities.focusMode.includes("manual")) {
                                        // For manual focus, set to infinity for barcode scanning
                                        if (capabilities.focusDistance) {
                                            const maxDistance = capabilities.focusDistance.max;
                                            advancedConstraints.advanced.push({ focusDistance: maxDistance });
                                        }
                                    }
                                }
                                
                                // Exposure optimization
                                if (capabilities.exposureMode?.includes("continuous")) {
                                    advancedConstraints.advanced.push({ exposureMode: "continuous" });
                                }
                                
                                // White balance
                                if (capabilities.whiteBalanceMode?.includes("continuous")) {
                                    advancedConstraints.advanced.push({ whiteBalanceMode: "continuous" });
                                }
                                
                                // Brightness and contrast
                                if (capabilities.brightness) {
                                    const midBrightness = (capabilities.brightness.min + capabilities.brightness.max) / 2;
                                    advancedConstraints.advanced.push({ brightness: midBrightness + 10 });
                                }
                                
                                if (capabilities.contrast) {
                                    const midContrast = (capabilities.contrast.min + capabilities.contrast.max) / 2;
                                    advancedConstraints.advanced.push({ contrast: midContrast + 10 });
                                }
                                
                                // Sharpness
                                if (capabilities.sharpness) {
                                    const maxSharpness = capabilities.sharpness.max;
                                    advancedConstraints.advanced.push({ sharpness: maxSharpness });
                                }
                                
                                // Apply all constraints
                                if (advancedConstraints.advanced.length > 0) {
                                    await track.applyConstraints(advancedConstraints);
                                    console.log("Applied advanced constraints:", advancedConstraints);
                                }
                                
                                // Log final settings
                                const finalSettings = track.getSettings();
                                console.log("Final settings:", finalSettings);
                                
                            } catch (e) {
                                console.log("Camera constraints error:", e);
                            }
                        }

                        const scan = async () => {
                            try {
                                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                                    const codes = await detector.detect(video);
                                    if (codes.length > 0) {
                                        const val = codes[0].rawValue;
                                        if (canAcceptCode(val)) {
                                            setBarcode(val);
                                            setScannedList(prev => [...prev, val]);
                                            playBeep();
                                            setFlashEffect(true);
                                            setTimeout(() => setFlashEffect(false), 300);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.log("Detection error:", e);
                            }
                            rafId = setTimeout(scan, 100);
                        };
                        scan();
                    } catch (err) {
                        console.error("Native scanner error:", err);
                        alert("Kh√¥ng th·ªÉ m·ªü camera. Vui l√≤ng cho ph√©p quy·ªÅn camera.");
                    }
                };

                // Quagga fallback (Safari, Firefox)
                const startQuagga = () => {
                    // Clear scanner first
                    scannerEl.innerHTML = "";
                    
                    Quagga.init(
                        {
                            inputStream: {
                                type: "LiveStream",
                                target: scannerEl,
                                constraints: {
                                    facingMode: "environment",
                                    width: { min: 640, ideal: 1920, max: 4096 },
                                    height: { min: 480, ideal: 1080, max: 2160 },
                                    aspectRatio: 16/9,
                                    focusMode: "continuous",
                                    advanced: [
                                        { focusMode: "continuous" },
                                        { exposureMode: "continuous" }
                                    ]
                                }
                            },
                            decoder: {
                                readers: [
                                    "code_128_reader",
                                    "ean_reader",
                                    "ean_8_reader",
                                    "code_39_reader",
                                    "upc_reader"
                                ],
                                multiple: false
                            },
                            locate: true,
                            locator: {
                                patchSize: "large",
                                halfSample: false
                            },
                            numOfWorkers: 4,
                            frequency: 10,
                            debug: {
                                drawBoundingBox: false,
                                showFrequency: false,
                                drawScanline: false,
                                showPattern: false
                            }
                        },
                        (err) => {
                            if (err) {
                                console.error("Quagga init error:", err);
                                alert("Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông camera qu√©t m√£ v·∫°ch");
                                return;
                            }
                            Quagga.start();
                            quaggaStarted = true;
                            console.log("Quagga started");
                        }
                    );

                    Quagga.onDetected((result) => {
                        const val = result.codeResult.code;
                        if (val && canAcceptCode(val)) {
                            setBarcode(val);
                            setScannedList(prev => [...prev, val]);
                            playBeep();
                            setFlashEffect(true);
                            setTimeout(() => setFlashEffect(false), 300);
                        }
                    });
                };

                // Start appropriate scanner
                try {
                    if (supportsBarcodeDetector) {
                        console.log("Using native BarcodeDetector");
                        startNative();
                    } else {
                        console.log("Using Quagga fallback");
                        startQuagga();
                    }
                } catch (e) {
                    console.error("Scanner start error:", e);
                    alert("L·ªói khi kh·ªüi ƒë·ªông camera");
                    setCameraOn(false);
                }

                return () => {
                    console.log("Cleanup useEffect");
                    stopAll();
                };
            }, [cameraOn, supportsBarcodeDetector]);

            const handlePhoto = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setPhoto(file);
                const reader = new FileReader();
                reader.onloadend = () => setPhotoPreview(reader.result);
                reader.readAsDataURL(file);
            };

            const saveWebhookUrl = (url) => {
                setWebhookUrl(url);
                localStorage.setItem("webhookUrl", url);
            };

            const sendToN8n = async () => {
                if (scannedList.length === 0 && !photo) {
                    alert("‚ö†Ô∏è Ch∆∞a c√≥ d·ªØ li·ªáu! Vui l√≤ng qu√©t m√£ v·∫°ch ho·∫∑c ch·ª•p ·∫£nh.");
                    return;
                }

                if (!webhookUrl || webhookUrl === "https://your-n8n-instance.com/webhook/thu-hoi-tai-san") {
                    alert("‚ö†Ô∏è Vui l√≤ng nh·∫≠p Webhook URL t·ª´ n8n!");
                    return;
                }

                // Check if using localhost
                if (webhookUrl.includes("localhost") || webhookUrl.includes("127.0.0.1")) {
                    alert("‚ùå L·ªói: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn localhost t·ª´ ƒëi·ªán tho·∫°i!\n\n" +
                          "Gi·∫£i ph√°p:\n" +
                          "1. D√πng IP m√°y t√≠nh (VD: http://192.168.1.100:5678/webhook/...)\n" +
                          "2. Ho·∫∑c host n8n online v√† d√πng HTTPS URL\n" +
                          "3. Ho·∫∑c d√πng ngrok ƒë·ªÉ t·∫°o tunnel\n\n" +
                          "C√°ch l·∫•y IP m√°y t√≠nh:\n" +
                          "- Windows: cmd ‚Üí ipconfig\n" +
                          "- Mac/Linux: terminal ‚Üí ifconfig");
                    return;
                }

                setLoading(true);
                setStatus("");

                try {
                    let photoBase64 = null;
                    if (photo) {
                        photoBase64 = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result);
                            reader.readAsDataURL(photo);
                        });
                    }

                    const payload = {
                        barcodes: scannedList,
                        mainBarcode: scannedList[scannedList.length - 1] || "",
                        photo: photoBase64,
                        timestamp: new Date().toISOString(),
                        device: navigator.userAgent,
                        totalScanned: scannedList.length
                    };

                    console.log("Sending to:", webhookUrl);
                    console.log("Payload size:", JSON.stringify(payload).length, "bytes");

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

                    const response = await fetch(webhookUrl, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (response.ok) {
                        setStatus("success");
                        // Reset form
                        setScannedList([]);
                        setBarcode("");
                        setPhoto(null);
                        setPhotoPreview(null);
                        playBeep();
                    } else {
                        setStatus("error");
                        const errorText = await response.text();
                        alert(`‚ùå L·ªói t·ª´ server:\n\nStatus: ${response.status} ${response.statusText}\n\nChi ti·∫øt: ${errorText.substring(0, 200)}`);
                    }
                } catch (error) {
                    console.error("Send error:", error);
                    setStatus("error");
                    
                    let errorMsg = "‚ùå L·ªói k·∫øt n·ªëi!\n\n";
                    
                    if (error.name === 'AbortError') {
                        errorMsg += "‚è±Ô∏è Timeout: M·∫•t qu√° 30 gi√¢y ƒë·ªÉ k·∫øt n·ªëi.\n\n";
                        errorMsg += "Gi·∫£i ph√°p:\n";
                        errorMsg += "- Ki·ªÉm tra k·∫øt n·ªëi internet\n";
                        errorMsg += "- Ki·ªÉm tra n8n c√≥ ƒëang ch·∫°y kh√¥ng\n";
                        errorMsg += "- Th·ª≠ l·∫°i sau";
                    } else if (error.message.includes("Failed to fetch") || error.message.includes("Network request failed")) {
                        errorMsg += "üåê Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server.\n\n";
                        errorMsg += "Nguy√™n nh√¢n c√≥ th·ªÉ:\n";
                        errorMsg += "1. URL webhook sai\n";
                        errorMsg += "2. n8n ch∆∞a ch·∫°y ho·∫∑c kh√¥ng accessible\n";
                        errorMsg += "3. ƒêi·ªán tho·∫°i v√† m√°y t√≠nh kh√¥ng c√πng m·∫°ng WiFi\n";
                        errorMsg += "4. Firewall ch·∫∑n k·∫øt n·ªëi\n\n";
                        errorMsg += "URL hi·ªán t·∫°i:\n" + webhookUrl + "\n\n";
                        errorMsg += "Gi·∫£i ph√°p:\n";
                        errorMsg += "- Ki·ªÉm tra n8n c√≥ ch·∫°y kh√¥ng\n";
                        errorMsg += "- Ki·ªÉm tra URL c√≥ ƒë√∫ng kh√¥ng\n";
                        errorMsg += "- Th·ª≠ ping t·ª´ m√°y t√≠nh: curl " + webhookUrl;
                    } else {
                        errorMsg += "Chi ti·∫øt: " + error.message;
                    }
                    
                    alert(errorMsg);
                }

                setLoading(false);
                setTimeout(() => setStatus(""), 3000);
            };

            const toggleTorch = async () => {
                const track = videoTrackRef.current;
                if (!track) return;
                
                const capabilities = track.getCapabilities?.();
                if (capabilities?.torch) {
                    try {
                        await track.applyConstraints({
                            advanced: [{ torch: !torch }]
                        });
                        setTorch(!torch);
                    } catch (e) {
                        console.log("Torch error:", e);
                        alert("ƒêi·ªán tho·∫°i n√†y kh√¥ng h·ªó tr·ª£ ƒë√®n flash");
                    }
                } else {
                    alert("ƒêi·ªán tho·∫°i n√†y kh√¥ng h·ªó tr·ª£ ƒë√®n flash");
                }
            };

            const tapToFocus = async (e) => {
                const track = videoTrackRef.current;
                if (!track) return;
                
                const capabilities = track.getCapabilities?.();
                if (capabilities?.focusMode?.includes("manual")) {
                    try {
                        // Force refocus
                        await track.applyConstraints({
                            advanced: [{ focusMode: "continuous" }]
                        });
                        console.log("Refocused");
                    } catch (err) {
                        console.log("Focus error:", err);
                    }
                }
            };

            const removeBarcode = (index) => {
                setScannedList(prev => prev.filter((_, i) => i !== index));
            };

            const clearAll = () => {
                if (confirm("X√≥a t·∫•t c·∫£ m√£ v·∫°ch ƒë√£ qu√©t?")) {
                    setScannedList([]);
                    setBarcode("");
                }
            };

            const testConnection = async () => {
                if (!webhookUrl || webhookUrl === "https://your-n8n-instance.com/webhook/thu-hoi-tai-san") {
                    alert("‚ö†Ô∏è Vui l√≤ng nh·∫≠p Webhook URL tr∆∞·ªõc!");
                    return;
                }

                if (webhookUrl.includes("localhost") || webhookUrl.includes("127.0.0.1")) {
                    alert("‚ùå Kh√¥ng th·ªÉ test localhost t·ª´ ƒëi·ªán tho·∫°i!\n\nH√£y thay b·∫±ng IP m√°y t√≠nh (VD: 192.168.1.100)");
                    return;
                }

                setLoading(true);
                try {
                    const testPayload = {
                        test: true,
                        message: "Test connection from mobile app",
                        timestamp: new Date().toISOString()
                    };

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);

                    const response = await fetch(webhookUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(testPayload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (response.ok) {
                        alert("‚úÖ K·∫øt n·ªëi th√†nh c√¥ng!\n\nn8n ƒë√£ nh·∫≠n ƒë∆∞·ª£c test request.");
                    } else {
                        alert(`‚ö†Ô∏è Server ph·∫£n h·ªìi nh∆∞ng c√≥ l·ªói:\n\nStatus: ${response.status}\nMessage: ${response.statusText}`);
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        alert("‚ùå Timeout!\n\nKh√¥ng th·ªÉ k·∫øt n·ªëi sau 10 gi√¢y.\n\nKi·ªÉm tra:\n- n8n c√≥ ch·∫°y kh√¥ng?\n- URL c√≥ ƒë√∫ng kh√¥ng?\n- C√πng m·∫°ng WiFi ch∆∞a?");
                    } else {
                        alert("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi!\n\n" + error.message + "\n\nKi·ªÉm tra l·∫°i URL v√† ƒë·∫£m b·∫£o n8n ƒëang ch·∫°y.");
                    }
                }
                setLoading(false);
            };

            return (
                <div className="max-w-md mx-auto p-4 space-y-4 pb-8">
                    {/* Header */}
                    <div className="bg-white rounded-xl shadow-lg p-4 mt-4">
                        <div className="flex items-center gap-3 mb-2">
                            <span className="text-3xl">üì¶</span>
                            <h1 className="text-2xl font-bold text-gray-800">Thu H·ªìi T√†i S·∫£n</h1>
                        </div>
                        <p className="text-sm text-gray-500">Qu√©t m√£ v·∫°ch t·ª± ƒë·ªông v√† ch·ª•p ·∫£nh v·∫≠t t∆∞</p>
                    </div>

                    {/* Webhook URL */}
                    <div className="bg-white rounded-xl shadow-lg p-4">
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            üîó Webhook URL n8n
                        </label>
                        <input
                            type="text"
                            value={webhookUrl}
                            onChange={(e) => saveWebhookUrl(e.target.value)}
                            className="w-full px-3 py-2 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-sm"
                            placeholder="http://192.168.1.100:5678/webhook/..."
                        />
                        <button
                            onClick={testConnection}
                            disabled={loading}
                            className="w-full mt-2 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm font-medium"
                        >
                            {loading ? "ƒêang test..." : "üîå Test k·∫øt n·ªëi"}
                        </button>
                        <div className="mt-2 p-2 bg-yellow-50 rounded border border-yellow-200">
                            <p className="text-xs text-yellow-800">
                                ‚ö†Ô∏è <strong>Kh√¥ng d√πng localhost!</strong><br/>
                                Thay b·∫±ng IP m√°y t√≠nh (VD: http://192.168.1.100:5678/webhook/thu-hoi-tai-san)
                            </p>
                        </div>
                    </div>

                    {/* Manual Barcode Input */}
                    <div className="bg-white rounded-xl shadow-lg p-4">
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            üìù Nh·∫≠p m√£ v·∫°ch th·ªß c√¥ng (n·∫øu kh√¥ng qu√©t ƒë∆∞·ª£c)
                        </label>
                        <div className="flex gap-2">
                            <input
                                type="text"
                                value={barcode}
                                onChange={(e) => setBarcode(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter' && barcode.trim()) {
                                        if (canAcceptCode(barcode.trim())) {
                                            setScannedList(prev => [...prev, barcode.trim()]);
                                            playBeep();
                                            setFlashEffect(true);
                                            setTimeout(() => setFlashEffect(false), 300);
                                        }
                                        setBarcode("");
                                    }
                                }}
                                className="flex-1 px-3 py-2 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent font-mono"
                                placeholder="Nh·∫≠p m√£ ho·∫∑c qu√©t b·∫±ng m√°y qu√©t c·∫ßm tay"
                            />
                            <button
                                onClick={() => {
                                    if (barcode.trim() && canAcceptCode(barcode.trim())) {
                                        setScannedList(prev => [...prev, barcode.trim()]);
                                        playBeep();
                                        setFlashEffect(true);
                                        setTimeout(() => setFlashEffect(false), 300);
                                        setBarcode("");
                                    }
                                }}
                                disabled={!barcode.trim()}
                                className={`px-4 py-2 rounded-lg font-medium text-white ${
                                    barcode.trim() 
                                        ? "bg-indigo-600 hover:bg-indigo-700" 
                                        : "bg-gray-400 cursor-not-allowed"
                                }`}
                            >
                                ‚ûï
                            </button>
                        </div>
                        <p className="text-xs text-gray-500 mt-2">üí° Nh·∫•n Enter ho·∫∑c n√∫t ‚ûï ƒë·ªÉ th√™m m√£</p>
                    </div>

                    {/* Camera Control */}
                    <button
                        onClick={() => setCameraOn(v => !v)}
                        className={`w-full p-4 rounded-xl font-bold text-white shadow-lg transition-all ${
                            cameraOn 
                                ? "bg-red-600 hover:bg-red-700" 
                                : "bg-green-600 hover:bg-green-700"
                        }`}
                    >
                        {cameraOn ? "‚è∏ T·∫Øt Camera Qu√©t" : "‚ñ∂Ô∏è B·∫≠t Camera Qu√©t M√£ T·ª± ƒê·ªông"}
                    </button>

                    {/* Scanner - Only show when camera is on */}
                    {cameraOn && (
                        <div>
                            <div id="scanner-wrapper" className={flashEffect ? "beep-success" : ""} onClick={tapToFocus}>
                                <div id="scanner">
                                    <div style={{display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', color: '#9ca3af', textAlign: 'center', padding: '1rem'}}>
                                        <div>
                                            <span style={{fontSize: '3rem', display: 'block', marginBottom: '0.5rem'}}>üì∑</span>
                                            <p>ƒêang kh·ªüi ƒë·ªông camera...</p>
                                        </div>
                                    </div>
                                </div>
                                <div className="overlay">
                                    <div className="scan-area">
                                        <div className="scan-line"></div>
                                        <div className="corner corner-tl"></div>
                                        <div className="corner corner-tr"></div>
                                        <div className="corner corner-bl"></div>
                                        <div className="corner corner-br"></div>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Camera Controls */}
                            <div className="flex gap-2 mt-2">
                                <button
                                    onClick={toggleTorch}
                                    className={`flex-1 p-3 rounded-lg font-medium ${
                                        torch 
                                            ? "bg-yellow-500 text-white" 
                                            : "bg-gray-200 text-gray-700"
                                    }`}
                                >
                                    {torch ? "üî¶ T·∫Øt ƒë√®n" : "üí° B·∫≠t ƒë√®n flash"}
                                </button>
                                <button
                                    onClick={tapToFocus}
                                    className="flex-1 p-3 rounded-lg font-medium bg-blue-500 text-white"
                                >
                                    üéØ L·∫•y n√©t l·∫°i
                                </button>
                            </div>
                            
                            <p className="text-xs text-gray-500 text-center mt-2">
                                üí° Nh·∫•n v√†o m√†n h√¨nh camera ƒë·ªÉ l·∫•y n√©t | D√πng ƒë√®n flash n·∫øu thi·∫øu s√°ng
                            </p>
                        </div>
                    )}

                    {/* Scanned List */}
                    {scannedList.length > 0 && (
                        <div className="bg-white rounded-xl shadow-lg p-4">
                            <div className="flex justify-between items-center mb-2">
                                <b className="text-gray-800">üìã ƒê√£ qu√©t ({scannedList.length})</b>
                                <button 
                                    onClick={clearAll}
                                    className="text-red-600 text-sm font-medium"
                                >
                                    üóëÔ∏è X√≥a t·∫•t c·∫£
                                </button>
                            </div>
                            <div className="max-h-48 overflow-auto space-y-2">
                                {scannedList.map((code, i) => (
                                    <div 
                                        key={i} 
                                        className="flex justify-between items-center bg-gray-50 p-2 rounded border border-gray-200"
                                    >
                                        <span className="font-mono text-sm">{code}</span>
                                        <button 
                                            onClick={() => removeBarcode(i)}
                                            className="text-red-500 text-xs"
                                        >
                                            ‚úï
                                        </button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Photo Capture */}
                    <div className="bg-white rounded-xl shadow-lg p-4">
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                            üì∑ Ch·ª•p ·∫¢nh V·∫≠t T∆∞
                        </label>
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="image/*"
                            capture="environment"
                            onChange={handlePhoto}
                            className="hidden"
                        />
                        <button
                            onClick={() => fileInputRef.current?.click()}
                            className="w-full py-3 border-2 border-dashed border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-colors"
                        >
                            <span className="text-gray-700 font-medium">
                                {photo ? "üì∏ Ch·ª•p l·∫°i ·∫£nh" : "üì∏ Ch·ª•p ·∫£nh v·∫≠t t∆∞"}
                            </span>
                        </button>
                        {photoPreview && (
                            <div className="mt-3 rounded-lg overflow-hidden border-2 border-gray-200">
                                <img src={photoPreview} alt="Preview" className="w-full" />
                            </div>
                        )}
                    </div>

                    {/* Submit Button */}
                    <button
                        onClick={sendToN8n}
                        disabled={loading || (scannedList.length === 0 && !photo)}
                        className={`w-full py-4 rounded-xl font-bold text-white shadow-xl transition-all ${
                            loading || (scannedList.length === 0 && !photo)
                                ? "bg-gray-400 cursor-not-allowed"
                                : "bg-indigo-600 hover:bg-indigo-700"
                        }`}
                    >
                        {loading ? (
                            <span className="flex items-center justify-center gap-2">
                                <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                                ƒêang g·ª≠i...
                            </span>
                        ) : (
                            "üöÄ G·ª≠i D·ªØ Li·ªáu L√™n n8n"
                        )}
                    </button>

                    {/* Status Messages */}
                    {status === "success" && (
                        <div className="flex items-center gap-2 p-4 bg-green-50 border border-green-200 rounded-xl">
                            <span className="text-2xl">‚úÖ</span>
                            <span className="text-green-800 font-medium">G·ª≠i th√†nh c√¥ng!</span>
                        </div>
                    )}

                    {status === "error" && (
                        <div className="flex items-center gap-2 p-4 bg-red-50 border border-red-200 rounded-xl">
                            <span className="text-2xl">‚ùå</span>
                            <span className="text-red-800 font-medium">L·ªói! Ki·ªÉm tra l·∫°i.</span>
                        </div>
                    )}

                    {/* Instructions */}
                    <div className="bg-white rounded-xl shadow-lg p-4">
                        <h3 className="font-semibold text-gray-800 mb-3">üí° H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng:</h3>
                        
                        <div className="mb-3 p-3 bg-red-50 rounded-lg border border-red-200">
                            <p className="text-sm text-red-800 font-semibold mb-2">
                                üö® L·ªñI K·∫æT N·ªêI? ƒê·ªåC ƒê√ÇY!
                            </p>
                            <p className="text-sm text-red-700 mb-2">
                                <strong>V·∫•n ƒë·ªÅ:</strong> Kh√¥ng th·ªÉ d√πng <code className="bg-red-100 px-1 rounded">localhost</code> ho·∫∑c <code className="bg-red-100 px-1 rounded">127.0.0.1</code> t·ª´ ƒëi·ªán tho·∫°i!
                            </p>
                            <p className="text-sm text-red-700 mb-2">
                                <strong>Gi·∫£i ph√°p:</strong> D√πng IP m√°y t√≠nh
                            </p>
                            <div className="text-xs text-red-600 space-y-1 mt-2">
                                <p><strong>Windows:</strong> M·ªü CMD ‚Üí g√µ <code className="bg-red-100 px-1">ipconfig</code> ‚Üí t√¨m "IPv4 Address"</p>
                                <p><strong>Mac:</strong> System Preferences ‚Üí Network ‚Üí xem IP</p>
                                <p><strong>Linux:</strong> Terminal ‚Üí <code className="bg-red-100 px-1">hostname -I</code></p>
                                <p className="mt-2"><strong>VD URL ƒë√∫ng:</strong></p>
                                <code className="bg-red-100 px-2 py-1 rounded block mt-1">
                                    http://192.168.1.100:5678/webhook/thu-hoi-tai-san
                                </code>
                            </div>
                        </div>
                        
                        <ol className="text-sm text-gray-600 space-y-2 list-decimal list-inside">
                            <li>L·∫•y IP m√°y t√≠nh (xem h∆∞·ªõng d·∫´n tr√™n)</li>
                            <li>ƒê·∫£m b·∫£o ƒëi·ªán tho·∫°i v√† m√°y t√≠nh <strong>c√πng WiFi</strong></li>
                            <li>Nh·∫≠p URL webhook v·ªõi IP m√°y t√≠nh</li>
                            <li>Click "Test k·∫øt n·ªëi" ƒë·ªÉ ki·ªÉm tra</li>
                            <li>Nh·∫≠p m√£ v·∫°ch ho·∫∑c b·∫≠t camera qu√©t</li>
                            <li>Ch·ª•p ·∫£nh v·∫≠t t∆∞</li>
                            <li>G·ª≠i d·ªØ li·ªáu l√™n n8n</li>
                        </ol>
                        
                        <div className="mt-3 p-3 bg-green-50 rounded-lg border border-green-200">
                            <p className="text-sm text-green-800">
                                <strong>‚úÖ Checklist:</strong><br/>
                                ‚ñ° n8n ƒëang ch·∫°y tr√™n m√°y t√≠nh<br/>
                                ‚ñ° Workflow ƒë√£ Active<br/>
                                ‚ñ° ƒêi·ªán tho·∫°i v√† m√°y t√≠nh c√πng WiFi<br/>
                                ‚ñ° ƒê√£ thay localhost b·∫±ng IP m√°y t√≠nh<br/>
                                ‚ñ° Test connection th√†nh c√¥ng
                            </p>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
</body>
</html>
